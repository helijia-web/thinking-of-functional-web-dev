## 敏捷开发为什么能生效


价值： 理解敏捷软件开发为什么能生效的原因，而不仅仅停留在执行流程和应用工具。


前几天，公司的大牛 沃兹 分享了《领域建模》，因为我是最后才去听的，所以只听了一部分，尽管如此，也收获很多，深有同感。

最后讲到敏捷软件开发这一部分，有一些想法先记录下来，

说到敏捷软件开发，可能有很多人就会想到 进度看板、快速编码、简单设计、Scrum等等**流程**。 可你有没思考过一个问题：**它为什么能生效呢？** 流程往往容易掌握，也容易**学习**，也更方便被公司执行。 这样就容易产生为了敏捷而敏捷，以至于这两年会有不少 **敏捷已死** 的论调，前些年我和同行交流时，会自豪说我们采用敏捷软件开发， 现在聊时就不好意思说了， 因为他们的HR或管理者会回复，那不是前几年流行的吗？这几年我听说可以使用XXX开发方法，敏捷开发成了流行的服饰，过几年就得换换。

**敏捷开发为什么能够生效？**

所谓的传统的软件开发流程大概是这样

需求分析->概要设计->详细设计->编码->测试->维护。

并且会重视流程的时间次序，在需求分析和设计阶段往往非常 **全面** 和**小心** ，很怕遗漏什么到后面发现时，这修改成本就大了。

也就是说，它基于一个事实， **越后来的修改越难，修改成本和维护成本，会随着时间呈指数级增长**，可能我们可能有在”“软件工程”的书中看过这样的曲线 ，所以我们必须在前面考虑周全，设计全面。

这对于软件开发，需求变化没那么快速，需求明确情况下比较好使。

而对于Web项目，以及现在的创业型公司，需求其实是边开发边摸索的，很多时候东西没做出来是不知道我们到底要什么，你 **需要的是边做边改才知道做什么**，这样的话这个模型就不符合了。
也就是说根本考虑不周全，也设计不全面，因为待解决的问题不知道是什么。

另一方面，如果我们 开发工程师，我更喜欢称我们为“软件工匠” 有一种绝活，**可以拉平上面可怕的指数曲线，让它变成线性**，即让后面的修修改改，揉揉捏捏和前面一样容易 那么开发流程应该怎么设计呢？

于是就有了大家熟知的敏捷流程。所以我们都被带进了一个坑，就是忘记了真正重要的是 **维持这条开发成本曲线线性**，那些流程和工具才生效。

那如何才能够拥有这条完美曲线呢？而这也是最难的，难的不是不知道怎么做，而
是 **它不是知识，不是流程和工具，而是**技能**。需要刻意练习才能获得。

**区分知识和技能， 对我们工程师来说非常重要**，这也是为什么很多开发工程师始终在学习，即一直停留在 **感觉都会，就是写不出来**的阶段，是因为我们是不可能靠看书，看网页，听分享来掌握技能，这道理很简单，就象不可能靠看书来学会打篮球一样。

然后，我想简单聊聊如何保持那条线是线性的。

我就以 沃兹 分享的两个方面 领域模型 和单元测试为切入讲讲如何真正敏捷开发。

软件开发的结果是代码， 代码就是一种信息的表达方式，更准确地说是 **信息的组织方式**。 通过找到一种组织方式来有效地描述问题，不仅可以描述当前的问题，而且可以描述未来的问题。

在这种组织方式里，内含很多预先埋好的维度，会存在一种模型，这种模型内含很多维度，在这些维度方向上，可以自由伸缩，而需求的变更或者增添就相当于在这些维度方向上行走。而这样的结构往往是抽象的，却又能够很好地表达问题域的， 这种东西就叫“领域模型“，如果找到这些维度如何设计这个即抽象又精确的抽型就是”领域建模“需要做的事情。

上面说的是一种结果，即我们通过某种神秘的力量，或者说上帝视角，一眼看穿本质，直接还原出问题的领域模型，那么我们就能在修改时不那么费劲，能够将那么成本曲线变成水平。

但是现实情况下我们不可能拥有这种能力，所以要采用类似于启发式的探索算法。

我们只要 **时时保持当前的结构**，让其拥有清晰的维度，而当前所有的问题点都被有序地包含在内，没有特殊的点偏离。

然后基于一个事实，世界是连续的，那么变化也是连续，即需求变更尽量千变万化，但总是在当前的条件下出发完成的， 我们就能够保证 后续的维度成本同样可控，使用这种方法就能够 **维持开发成本曲线成线性**，在这种模式下，我们的开发成本会有两方面的支出。

第一步是为了保持这个结构不被破坏，所有点都在所描述的维度内。这个过程叫 **重构**。

第二步是在上一步的基础上，在预先设计的维度内，很自然上挂上新变更的需求。

上面两步就是真正的敏捷软件开发。尤其是第一步非常重要，也最容易被放弃。

正因为第一步是敏捷开发的关键，为了使调调整安全可靠，而强调甚至重新定义了 **单元测试**。

刚才说到，我们 必须时刻保持模型的有效性，那么免不了持续对我们的结构中的各个部分折折再重新装装。那么如何保证我们各个模块具有这种容易拆装组合的特性呢？ 答案就是**单元测试**，因为一个模块能被单元测试，那表示它更容易被隔离，更容易重新拆装。所以单元测试在敏捷开发里最重要是为 **保持被测模块的独立性**，或者以往术语叫低耦合，而不仅仅是测试模块是否正常工作。

如果一个模块还没产生前，我们就编写好对它的单元测试，那么这个模块必然具有好的特点，否则它就根本写出不来。

因为就两种情况：

一是已经有模块了，要添加单元测试，那么模块特性好，我们才能更容易添加单元测试，如果太复杂不好添加单元测试，这并不阻止我们继续完成功能，所以多数情况下就会放弃对这个模块的单元测试，最多写上一个TODO，让自己的心里好受些。

第二种是，如果先有单元测试，再写实现模块，那么你要把工作进行下去，唯一能做的就是调整单元测试，直到写出模块，然后模块自然具有优秀的特性。

这就是TDD，这里的重点是，TDD的T和D不是说先写完好多模块的测试，再写它们的实现，我更倾向于把它看成一个模块包含的两个不可分害的两部分，测试和实现，它们可以交替，轮流，反复，伴随而产生。

所以我觉得让敏捷软件开发真正起作用的是，我们应该在开发过程中应用以上实践，只是上述过程并不是个流程，而是个技能，所以需要刻意练习才能得以实施。

最后再谈谈简单设计， 有好多对敏捷开发不怎么了解的以为敏捷开发不重视设计，其实经过刚才的分析， 我们知道 **设计在敏捷开发中并不是一步流程，而是贯穿整个开发周期**， 只要还在维护，修改代码，就在时时设计。 上面描述的第一步其实做的就是设计。

所以这也是为什么说：

**重构就是设计**， 这里的设计是动词。

相对应的还有一句话：

**源代码即设计**， 这里的设计是名词。


